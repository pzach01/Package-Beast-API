from . import py3dbp_constants
from .py3dbp_constants import RotationType, Axis
from . import py3dbp_auxiliary_methods
from .py3dbp_auxiliary_methods import intersect

START_POSITION = [0, 0, 0]

class ItemPY3DBP:
    def __init__(self, name, width, height, depth, weight):

        self.name = name
        self.width = width
        self.height = height
        self.depth = depth
        self.weight = weight
        self.rotation_type = 0
        self.position = START_POSITION
        self.volume = self.get_volume()


    def string(self):
        return "%s(%fx%fx%f, weight: %s) pos(%f, %f, %f) rt(%s) vol(%s)" % (
            self.name, self.width, self.height, self.depth, self.weight,
            self.position[0], self.position[1], self.position[2], self.rotation_type, self.volume
        )

    def get_volume(self):
        return self.width * self.height * self.depth

    def get_dimension(self):
        if self.rotation_type == RotationType.RT_WHD:
            dimension = [self.width, self.height, self.depth]
        elif self.rotation_type == RotationType.RT_HWD:
            dimension = [self.height, self.width, self.depth]
        elif self.rotation_type == RotationType.RT_HDW:
            dimension = [self.height, self.depth, self.width]
        elif self.rotation_type == RotationType.RT_DHW:
            dimension = [self.depth, self.height, self.width]
        elif self.rotation_type == RotationType.RT_DWH:
            dimension = [self.depth, self.width, self.height]
        elif self.rotation_type == RotationType.RT_WDH:
            dimension = [self.width, self.depth, self.height]
        else:
            dimension = []

        return dimension


class ContainerPY3DBP:
    def __init__(self, name, width, height, depth, max_weight):
        self.name = name
        self.width = width
        self.height = height
        self.depth = depth
        self.max_weight = max_weight
        self.items = []
        self.unfitted_items = []
        self.volume = self.get_volume()

    def string(self):
        return "%s(%sx%sx%s, max_weight:%s) vol(%s)" % (
            self.name, self.width, self.height, self.depth, self.max_weight,
            self.volume
        )

    def get_volume(self):
        return self.width * self.height * self.depth

    def get_total_weight(self):
        total_weight = 0

        for item in self.items:
            total_weight += item.weight

        return total_weight


    def put_item(self, item, pivot):
            fit = False
            valid_item_position = item.position
            item.position = pivot

            for i in range(0, len(RotationType.ALL)):
                if item not in self.items:

                    item.rotation_type = i
                    dimension = item.get_dimension()
                    if (
                        self.width < pivot[0] + dimension[0] or
                        self.height < pivot[1] + dimension[1] or
                        self.depth < pivot[2] + dimension[2]
                    ):
                        continue

                    fit = True

                    for current_item_in_bin in self.items:
                        if intersect(current_item_in_bin, item):
                            fit = False
                            break

                    if fit:
                        if self.get_total_weight() + item.weight > self.max_weight:
                            fit = False
                            return fit

                        #print("item appended to bin:", item.string())
                        self.items.append(item)
                        

                    if not fit:
                        item.position = valid_item_position

                    return fit

            if not fit:
                item.position = valid_item_position

            return fit


        
        # def put_item(self, item, pivot):
        #     fit = False
        #     valid_item_position = item.position
        #     item.position = pivot

            
        #     for i in range(0, len(RotationType.ALL)):
                
        #         if fit == False:

        #             dimension = item.get_dimension()
                    

        #             if (
        #                 self.width < pivot[0] + dimension[0] or
        #                 self.height < pivot[1] + dimension[1] or
        #                 self.depth < pivot[2] + dimension[2]
        #             ):  
        #                 continue

        #             fit = True
        #             item.rotation_type = i   
        #             print(i)

        #             for current_item_in_bin in self.items:
        #                 if intersect(current_item_in_bin, item):
        #                     fit = False
        #                     break

        #             if fit:
        #                 if self.get_total_weight() + item.weight > self.max_weight:
        #                     fit = False
        #                     return fit
        #                 print("p-0", pivot[0], "p-1", pivot[1], "p-2", pivot[2])
        #                 print("dim-0", dimension[0], "dim-1", dimension[1], "dim-2", dimension[2])
        #                 print("rotation", item.rotation_type)
        #                 print("sss", item.string())
        #                 self.items.append(item)   

        #             if not fit:
        #                 item.position = valid_item_position
        #             return fit

        #     if not fit:
        #         item.position = valid_item_position 
        #     return fit
        


class Packer:
    def __init__(self):
        self.bins = []
        self.items = []
        self.unfit_items = []
        self.total_items = 0

    def add_bin(self, bin):
        return self.bins.append(bin)

    def add_item(self, item):
        self.total_items = len(self.items) + 1

        return self.items.append(item)

    def pack_to_bin(self, bin, item):
        fitted = False

        if not bin.items:
            response = bin.put_item(item, START_POSITION)

            if not response:
                bin.unfitted_items.append(item)

            return

        for axis in range(0, len(Axis.ALL)):
            for ib in bin.items:
                pivot = [0, 0, 0]
                if axis == Axis.WIDTH:
                    pivot = [
                        ib.position[0] + ib.width,
                        ib.position[1],
                        ib.position[2]
                    ]
                elif axis == Axis.HEIGHT:
                    pivot = [
                        ib.position[0],
                        ib.position[1] + ib.height,
                        ib.position[2]
                    ]
                elif axis == Axis.DEPTH:
                    pivot = [
                        ib.position[0],
                        ib.position[1],
                        ib.position[2] + ib.depth
                    ]

                if bin.put_item(item, pivot):
                    fitted = True
                    break

        if not fitted:
            bin.unfitted_items.append(item)

    def pack(self, bigger_first=False, distribute_items=False):
        self.bins.sort(key=lambda bin: bin.volume, reverse=bigger_first)
        # self.items.sort(key=lambda item: item.volume, reverse=bigger_first)

        for bin in self.bins:
            for item in self.items:
                self.pack_to_bin(bin, item)

            if distribute_items:
                for item in bin.items:
                    self.items.remove(item)
